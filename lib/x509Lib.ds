/**
 * X.509 certificate class.<br/>
 * @class X.509 certificate class
 * @property {RSAKey} subjectPublicKeyRSA Tom Wu's RSAKey object
 * @property {String} subjectPublicKeyRSA_hN hexadecimal string for modulus of RSA public key
 * @property {String} subjectPublicKeyRSA_hE hexadecimal string for public exponent of RSA public key
 * @property {String} hex hexacedimal string for X.509 certificate.
 */
  var Encoding = require('dw/crypto/Encoding');
 
 importScript('lib/base64Lib.ds');
 importScript('lib/rsaLib.ds');
 importScript('lib/asn1HexLib.ds');

exports.X509 = function X509() {
    this.subjectPublicKeyRSA    = null;
    this.subjectPublicKeyRSA_hN = null;
    this.subjectPublicKeyRSA_hE = null;
    this.hex                    = null;
    this.publicKey              = null;
    this.base64PublicKey        = null;
    this.ASN1HEX                = getASN1HEX();

    // ===== get basic fields from hex =====================================
  
    /**
     * get hexadecimal string of serialNumber field of certificate.<br/>
     * @name getSerialNumberHex
     * @memberOf X509#
     * @function
     */
    this.getSerialNumberHex = function() {
        return this.ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 1]);
    };

    /**
     * get hexadecimal string of issuer field TLV of certificate.<br/>
     * @name getIssuerHex
     * @memberOf X509#
     * @function
     */
    this.getIssuerHex = function() {
        return this.ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]);
    };
  
    /**
     * get string of issuer field of certificate.<br/>
     * @name getIssuerString
     * @memberOf X509#
     * @function
     */
    this.getIssuerString = function() {
        return this.hex2dn(this.ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]));
    };

    /**
     * get hexadecimal string of subject field of certificate.<br/>
     * @name getSubjectHex
     * @memberOf X509#
     * @function
     */
    this.getSubjectHex = function() {
        return this.ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]);
    };

    /**
     * get string of subject field of certificate.<br/>
     * @name getSubjectString
     * @memberOf X509#
     * @function
     */
    this.getSubjectString = function() {
        return this.hex2dn(this.ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]));
    };

    /**
     * get notBefore field string of certificate.<br/>
     * @name getNotBefore
     * @memberOf X509#
     * @function
     */
    this.getNotBefore = function() {
        var s = this.ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 0]);
        s = s.replace(/(..)/g, "%$1");
        s = decodeURIComponent(s);
        return s;
    };

    /**
     * get notAfter field string of certificate.<br/>
     * @name getNotAfter
     * @memberOf X509#
     * @function
     */
    this.getNotAfter = function() {
        var s = this.ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 1]);
        s = s.replace(/(..)/g, "%$1");
        s = decodeURIComponent(s);
        return s;
    };

    // ===== read certificate public key ==========================

    // ===== read certificate =====================================
    /**
     * read PEM formatted X.509 certificate from string.<br/>
     * @name readCertPEM
     * @memberOf X509#
     * @function
     * @param {String} sCertPEM string for PEM formatted X.509 certificate
     */
    this.readCertPEM = function(sCertPEM) {
        var hCert = this.pemToHex(sCertPEM);
        var a = this.getPublicKeyHexArrayFromCertHex(hCert);
        var rsa = new RSAKey();
        rsa.setPublic(a[0], a[1]);
        this.subjectPublicKeyRSA = rsa;
        this.subjectPublicKeyRSA_hN = a[0];
        this.subjectPublicKeyRSA_hE = a[1];
        this.hex = hCert;
    };
    
    this.readPublicKey = function(sCertPEM) {
    	var hCert = this.pemToHex(sCertPEM);
    	var key = this.getPublicKey(hCert);
    };

    this.readCertPEMWithoutRSAInit = function(sCertPEM) {
        var hCert = this.pemToHex(sCertPEM);
        var a = this.getPublicKeyHexArrayFromCertHex(hCert);
        this.subjectPublicKeyRSA.setPublic(a[0], a[1]);
        this.subjectPublicKeyRSA_hN = a[0];
        this.subjectPublicKeyRSA_hE = a[1];
        this.hex = hCert;
    };
    
    this.pemToBase64 = function(sCertPEM) {
	    var s = sCertPEM;
	    s = s.replace("-----BEGIN CERTIFICATE-----", "");
	    s = s.replace("-----END CERTIFICATE-----", "");
	    s = s.replace(/[ \n]+/g, "");
	    return s;
	};
	
	this.pemToHex = function(sCertPEM) {
	    var b64Cert = this.pemToBase64(sCertPEM);
	    var hCert = b64tohex(b64Cert);
	    return hCert;
	};
	
	this.getSubjectPublicKeyPosFromCertHex = function(hCert) {
	    var pInfo = this.getSubjectPublicKeyInfoPosFromCertHex(hCert);
	    if (pInfo == -1) return -1;    
	    var a = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pInfo); 
	    if (a.length != 2) return -1;
	    var pBitString = a[1];
	    if (hCert.substring(pBitString, pBitString + 2) != '03') return -1;
	    var pBitStringV = this.ASN1HEX.getStartPosOfV_AtObj(hCert, pBitString);
	    
	    if (hCert.substring(pBitStringV, pBitStringV + 2) != '00') return -1;
	    return pBitStringV + 2;
	};
	
		// NOTE: privateKeyUsagePeriod field of X509v2 not supported.
	// NOTE: v1 and v3 supported
	this.getSubjectPublicKeyInfoPosFromCertHex = function(hCert) {
	    var pTbsCert = this.ASN1HEX.getStartPosOfV_AtObj(hCert, 0);
	    var a = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pTbsCert); 
	    if (a.length < 1) return -1;
	    if (hCert.substring(a[0], a[0] + 10) == "a003020102") { // v3
	        if (a.length < 6) return -1;
	        return a[6];
	    } else {
	        if (a.length < 5) return -1;
	        return a[5];
	    }
	};
	
	
	
	/*
		This function is used to return public key in hex format 
	*/
	this.getPublicKey = function(hCert) {
		var pTbsCert = this.ASN1HEX.getStartPosOfV_AtObj(hCert, 0);
	    var a = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pTbsCert);
	    if (a.length < 1) return -1;
	    if (hCert.substring(a[0], a[0] + 10) == "a003020102") { // v3
	    	this.publicKey = hCert.substring(a[6], a[7]);
	        this.base64PublicKey = this.getBase64PublicKey(this.publicKey);
	    }
		return this.publicKey; 
	};
	
	/*
		This function is used to convert public key from hex to base64 format
	*/
	this.getBase64PublicKey = function(publicKey) {
		// get bytes representation of hax public key
		var bytesKey = Encoding.fromHex(publicKey);
		// convert bytes array to base64 representation
		var base64Key = Encoding.toBase64(bytesKey);
		return base64Key; 
	};
	
	this.getPublicKeyHexArrayFromCertHex = function(hCert) {
	    var p = this.getSubjectPublicKeyPosFromCertHex(hCert);
	    var a = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, p); 
	    if (a.length != 2) return [];
	    var hN = this.ASN1HEX.getHexOfV_AtObj(hCert, a[0]);
	    var hE = this.ASN1HEX.getHexOfV_AtObj(hCert, a[1]);
	    if (hN != null && hE != null) {
	        return [hN, hE];
	    } else {
	        return [];
	    }
	};
	
	/*this.getPublicKey = function(hCert) {
		var p = this.getSubjectPublicKeyPosFromCertHex(hCert);
		var a = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, p);
	};*/
	
	this.getHexTbsCertificateFromCert = function(hCert) {
	    var pTbsCert = this.ASN1HEX.getStartPosOfV_AtObj(hCert, 0);
	    return pTbsCert;
	};
	
	this.getPublicKeyHexArrayFromCertPEM = function(sCertPEM) {
	    var hCert = this.pemToHex(sCertPEM);
	    var a = this.getPublicKeyHexArrayFromCertHex(hCert);
	    return a;
	};
	
	this.hex2dn = function(hDN) {
	    var s = "";
	    var a = this.ASN1HEX.getPosArrayOfChildren_AtObj(hDN, 0);
	    for (var i = 0; i < a.length; i++) {
	        var hRDN = this.ASN1HEX.getHexOfTLV_AtObj(hDN, a[i]);
	        s = s + "/" + this.hex2rdn(hRDN);
	    }
	    return s;
	};
	
	this.hex2rdn = function(hRDN) {
	    var hType = this.ASN1HEX.getDecendantHexTLVByNthList(hRDN, 0, [0, 0]);
	    var hValue = this.ASN1HEX.getDecendantHexVByNthList(hRDN, 0, [0, 1]);
	    var type = "";
	    try { type = this.DN_ATTRHEX[hType]; } catch (ex) { type = hType; }
	    hValue = hValue.replace(/(..)/g, "%$1");
	    var value = decodeURIComponent(hValue);
	    return type + "=" + value;
	};
	
	this.DN_ATTRHEX = {
	    "0603550406": "C",
	    "060355040a": "O",
	    "060355040b": "OU",
	    "0603550403": "CN",
	    "0603550405": "SN",
	    "0603550408": "ST",
	    "0603550407": "L",
	};
	
		/**
	 * get RSAKey/ECDSA public key object from PEM certificate string
	 * @name getPublicKeyFromCertPEM
	 * @memberOf X509
	 * @function
	 * @param {String} sCertPEM PEM formatted RSA/ECDSA/DSA X.509 certificate
	 * @return returns RSAKey/KJUR.crypto.{ECDSA,DSA} object of public key
	 * @since x509 1.1.1
	 * @description
	 * NOTE: DSA is also supported since x509 1.1.2.
	 */
	X509.getPublicKeyFromCertPEM = function(sCertPEM) {
	    var info = this.getPublicKeyInfoPropOfCertPEM(sCertPEM);
	
	    if (info.algoid == "2a864886f70d010101") { // RSA
	        var aRSA = KEYUTIL.parsePublicRawRSAKeyHex(info.keyhex);
	        var key = new RSAKey();
	        key.setPublic(aRSA.n, aRSA.e);
	        return key;
	    } else if (info.algoid == "2a8648ce3d0201") { // ECC
	        var curveName = KJUR.crypto.OID.oidhex2name[info.algparam];
	        var key = new KJUR.crypto.ECDSA({'curve': curveName, 'info': info.keyhex});
	        key.setPublicKeyHex(info.keyhex);
	        return key;
	    } else if (info.algoid == "2a8648ce380401") { // DSA 1.2.840.10040.4.1
	        var p = this.ASN1HEX.getVbyList(info.algparam, 0, [0], "02");
	        var q = this.ASN1HEX.getVbyList(info.algparam, 0, [1], "02");
	        var g = this.ASN1HEX.getVbyList(info.algparam, 0, [2], "02");
	        var y = this.ASN1HEX.getHexOfV_AtObj(info.keyhex, 0);
	        y = y.substr(2);
	        var key = new KJUR.crypto.DSA();
	        key.setPublic(new BigInteger(p, 16),
	                      new BigInteger(q, 16),
	                      new BigInteger(g, 16),
	                      new BigInteger(y, 16));
	        return key;
	    } else {
	        throw "unsupported key";
	    }
	};
	
	/**
	 * get public key information from PEM certificate
	 * @name getPublicKeyInfoPropOfCertPEM
	 * @memberOf X509
	 * @function
	 * @param {String} sCertPEM string of PEM formatted certificate
	 * @return {Hash} hash of information for public key
	 * @since x509 1.1.1
	 * @description
	 * Resulted associative array has following properties:
	 * <ul>
	 * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>
	 * <li>algparam - hexadecimal string of OID of ECC curve name or null</li>
	 * <li>keyhex - hexadecimal string of key in the certificate</li>
	 * </ul>
	 * @since x509 1.1.1
	 */
	this.getPublicKeyInfoPropOfCertPEM = function(sCertPEM) {
	    var result = {};
	    result.algparam = null;
	    var hCert = this.pemToHex(sCertPEM);
	
	    // 1. Certificate ASN.1
	    var a1 = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, 0); 
	    if (a1.length != 3)
	        throw "malformed X.509 certificate PEM (code:001)"; // not 3 item of seq Cert
	
	    // 2. tbsCertificate
	    if (hCert.substr(a1[0], 2) != "30")
	        throw "malformed X.509 certificate PEM (code:002)"; // tbsCert not seq 
	
	    var a2 = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, a1[0]); 
	
	    // 3. subjectPublicKeyInfo
	    if (a2.length < 7)
	        throw "malformed X.509 certificate PEM (code:003)"; // no subjPubKeyInfo
	
	    var a3 = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, a2[6]); 
	
	    if (a3.length != 2)
	        throw "malformed X.509 certificate PEM (code:004)"; // not AlgId and PubKey
	
	    // 4. AlgId
	    var a4 = this.ASN1HEX.getPosArrayOfChildren_AtObj(hCert, a3[0]); 
	
	    if (a4.length != 2)
	        throw "malformed X.509 certificate PEM (code:005)"; // not 2 item in AlgId
	
	    result.algoid = this.ASN1HEX.getHexOfV_AtObj(hCert, a4[0]);
	
	    if (hCert.substr(a4[1], 2) == "06") { // EC
	        result.algparam = this.ASN1HEX.getHexOfV_AtObj(hCert, a4[1]);
	    } else if (hCert.substr(a4[1], 2) == "30") { // DSA
	        result.algparam = this.ASN1HEX.getHexOfTLV_AtObj(hCert, a4[1]);
	    }
	
	    // 5. Public Key Hex
	    if (hCert.substr(a3[1], 2) != "03")
	        throw "malformed X.509 certificate PEM (code:006)"; // not bitstring
	
	    var unusedBitAndKeyHex = this.ASN1HEX.getHexOfV_AtObj(hCert, a3[1]);
	    result.keyhex = unusedBitAndKeyHex.substr(2);
	
	    return result;
	};
	
		
};


/*
  X509.prototype.readCertPEM = _x509_readCertPEM;
  X509.prototype.readCertPEMWithoutRSAInit = _x509_readCertPEMWithoutRSAInit;
  X509.prototype.getSerialNumberHex = _x509_getSerialNumberHex;
  X509.prototype.getIssuerHex = _x509_getIssuerHex;
  X509.prototype.getSubjectHex = _x509_getSubjectHex;
  X509.prototype.getIssuerString = _x509_getIssuerString;
  X509.prototype.getSubjectString = _x509_getSubjectString;
  X509.prototype.getNotBefore = _x509_getNotBefore;
  X509.prototype.getNotAfter = _x509_getNotAfter;
*/
